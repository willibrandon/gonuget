# M3.13 RID Resolution - NuGet.Client Comparison

**Date**: 2025-10-22
**Comparison**: gonuget M3.13 implementation guide vs NuGet.Client RuntimeGraph

---

## Executive Summary

The M3.13 guide provides a **fundamentally correct** RID resolution implementation with proper JSON format and compatibility checking. However, several important details from NuGet.Client are missing that affect correctness and performance.

### Critical Issues
1. **Missing BFS expansion algorithm** - Affects RID ordering and nearest-match selection
2. **Missing 'any' and 'base' RIDs** - These are foundational RIDs in the official graph
3. **No expansion caching** - Performance issue for repeated compatibility checks

### Minor Issues
1. RuntimeDependencySet not implemented (likely out of scope for M3.13)
2. CompatibilityProfile ("supports" section) not implemented (may be future work)

---

## Detailed Comparison

### 1. JSON Format ✅ CORRECT

**Guide Implementation**:
```go
var graphData struct {
    Runtimes map[string]struct {
        Imports []string `json:"#import"`
    } `json:"runtimes"`
}
```

**NuGet.Client**:
```csharp
// JsonRuntimeFormat.cs:197-220
private static RuntimeDescription ReadRuntimeDescription(KeyValuePair<string, JToken> json)
{
    if (property.Key == "#import")
    {
        var imports = property.Value as JArray;
        foreach (var import in imports)
        {
            inheritedRuntimes ??= new();
            inheritedRuntimes.Add(import.Value<string>());
        }
    }
}
```

**Verdict**: ✅ The guide correctly uses `#import` as the JSON key, matching NuGet.Client exactly.

---

### 2. RID Expansion Algorithm ⚠️ CRITICAL GAP

**Guide Implementation**: (lines 1617-1632)
```go
// AreCompatible checks if targetRID is compatible with packageRID
func (g *RuntimeGraph) AreCompatible(targetRID, packageRID string) bool {
    // Exact match
    if targetRID == packageRID {
        return true
    }

    // Get target runtime
    target, ok := g.Runtimes[targetRID]
    if !ok {
        return false
    }

    // Check if packageRID is in target's imports (transitively)
    return g.isInImports(target, packageRID, make(map[string]bool))
}
```

**NuGet.Client** (RuntimeGraph.cs:172-220):
```csharp
/// <summary>
/// Find all compatible RIDs including the current RID.
/// </summary>
public IEnumerable<string> ExpandRuntime(string runtime)
{
    // Expand runtimes in a BFS walk. This ensures that nearest RIDs are returned first.
    // Ordering is important for finding the nearest runtime dependency.
    IEnumerable<string> ExpandRuntimeInternal(string runtime)
    {
        yield return runtime;

        // BFS traversal with deduplication
        var deduper = Cache<string>.RentHashSet();
        var expansions = Cache<string>.RentList();
        deduper.Add(runtime);
        expansions.Add(runtime);

        for (var i = 0; i < expansions.Count; i++)
        {
            if (Runtimes.TryGetValue(expansions[i], out RuntimeDescription? desc))
            {
                var inheritedRuntimes = desc.InheritedRuntimes;
                for (var r = 0; r < count; r++)
                {
                    var inheritedRuntime = inheritedRuntimes[r];
                    if (deduper.Add(inheritedRuntime))
                    {
                        yield return inheritedRuntime;
                        expansions.Add(inheritedRuntime);
                    }
                }
            }
        }
    }
}
```

**Key Differences**:

1. **Algorithm**: NuGet.Client uses **Breadth-First Search (BFS)**, the guide uses **recursive DFS**
2. **Ordering**: BFS ensures **nearest RIDs come first** (critical for asset selection)
3. **API**: NuGet.Client exposes `ExpandRuntime()` to get ALL compatible RIDs in order

**Impact**:
- Without BFS ordering, asset selection may pick wrong assets when multiple RID-specific versions exist
- Example: For `win10-x64`, should try `win10-x64` → `win10` → `win-x64` → `win` → `any` (BFS order)
- DFS might try `win10-x64` → `win10` → `win81` → ... → `any` → `win-x64` (wrong order)

**Recommendation**:
```go
// Add to ridgraph.go:

// ExpandRuntime returns all compatible RIDs in priority order (nearest first).
// Uses BFS traversal to ensure correct ordering for asset selection.
func (g *RuntimeGraph) ExpandRuntime(rid string) []string {
    var result []string
    visited := make(map[string]bool)
    queue := []string{rid}

    for len(queue) > 0 {
        current := queue[0]
        queue = queue[1:]

        if visited[current] {
            continue
        }
        visited[current] = true
        result = append(result, current)

        // Add imports to queue (BFS)
        if desc, ok := g.Runtimes[current]; ok {
            queue = append(queue, desc.Imports...)
        }
    }

    return result
}

// Update AreCompatible to use ExpandRuntime:
func (g *RuntimeGraph) AreCompatible(targetRID, packageRID string) bool {
    if targetRID == packageRID {
        return true
    }

    for _, compatRID := range g.ExpandRuntime(targetRID) {
        if compatRID == packageRID {
            return true
        }
    }

    return false
}
```

---

### 3. Caching Strategy ⚠️ PERFORMANCE ISSUE

**Guide Implementation**: No caching mentioned

**NuGet.Client** (RuntimeGraph.cs:20-23, 182-184):
```csharp
private readonly ConcurrentDictionary<RuntimeCompatKey, bool>? _areCompatible;
private readonly ConcurrentDictionary<string, HashSet<string>>? _expandCache;

private HashSet<string> ExpandRuntimeCached(string runtime)
{
    return _expandCache!.GetOrAdd(runtime, r =>
        new HashSet<string>(ExpandRuntimeInternal(r), StringComparer.Ordinal));
}

public bool AreCompatible(string criteria, string provided)
{
    var key = new RuntimeCompatKey(criteria, provided);
    return _areCompatible!.GetOrAdd(key, AreCompatibleInternal);
}
```

**Impact**:
- Without caching, RID expansion is recomputed for every compatibility check
- For a package with 100 files and 10 potential RIDs, that's 1000+ redundant expansions
- NuGet.Client caches both RID expansion and compatibility results

**Recommendation**:
```go
// Add to RuntimeGraph struct:
type RuntimeGraph struct {
    Runtimes map[string]*RuntimeDescription

    // Caches for performance
    expandCache   map[string][]string
    compatCache   map[compatKey]bool
    cacheMutex    sync.RWMutex
}

type compatKey struct {
    target  string
    package string
}

func (g *RuntimeGraph) ExpandRuntime(rid string) []string {
    g.cacheMutex.RLock()
    if cached, ok := g.expandCache[rid]; ok {
        g.cacheMutex.RUnlock()
        return cached
    }
    g.cacheMutex.RUnlock()

    // Compute expansion (BFS)
    result := g.expandRuntimeUncached(rid)

    g.cacheMutex.Lock()
    g.expandCache[rid] = result
    g.cacheMutex.Unlock()

    return result
}
```

---

### 4. Default RID Graph ⚠️ MISSING IMPORTANT RIDS

**Guide Implementation** (lines 1569-1607):
```go
// Windows
graph.AddRuntime("win", nil)
graph.AddRuntime("win-x86", []string{"win"})
graph.AddRuntime("win-x64", []string{"win"})
// ... etc

// Linux
graph.AddRuntime("linux", nil)
// ... etc

// macOS
graph.AddRuntime("osx", nil)
// ... etc
```

**Actual NuGet.Client runtime.json** (from test file):
```json
{
  "runtimes": {
    "base": {
    },
    "any": {
      "#import": [ "base" ]
    },
    "win": {
      "#import": [ "any" ]
    },
    "win-x86": {
      "#import": [ "win" ]
    },
    // ... etc
  }
}
```

**Missing RIDs**:
1. **`base`** - Root of all RID inheritance (has no imports)
2. **`any`** - Platform-agnostic RID (imports base)
3. All OS-specific RIDs should import `any`, not `nil`

**Impact**:
- Packages with `runtimes/any/` folder won't be found
- Compatibility chain is broken (should always fallback to `any` → `base`)
- Doesn't match official .NET RID catalog

**Recommendation**:
```go
func LoadDefaultRuntimeGraph() *RuntimeGraph {
    graph := NewRuntimeGraph()

    // Foundation RIDs (always include these)
    graph.AddRuntime("base", nil)
    graph.AddRuntime("any", []string{"base"})

    // Windows (all import any)
    graph.AddRuntime("win", []string{"any"})
    graph.AddRuntime("win-x86", []string{"win"})
    graph.AddRuntime("win-x64", []string{"win"})
    graph.AddRuntime("win-arm", []string{"win"})
    graph.AddRuntime("win-arm64", []string{"win"})

    // Version-specific Windows RIDs
    graph.AddRuntime("win7", []string{"win"})
    graph.AddRuntime("win7-x86", []string{"win7", "win-x86"})
    graph.AddRuntime("win7-x64", []string{"win7", "win-x64"})

    graph.AddRuntime("win8", []string{"win7"})
    graph.AddRuntime("win8-x86", []string{"win8", "win7-x86"})
    graph.AddRuntime("win8-x64", []string{"win8", "win7-x64"})
    graph.AddRuntime("win8-arm", []string{"win8", "win-arm"})

    graph.AddRuntime("win81", []string{"win8"})
    graph.AddRuntime("win81-x86", []string{"win81", "win8-x86"})
    graph.AddRuntime("win81-x64", []string{"win81", "win8-x64"})
    graph.AddRuntime("win81-arm", []string{"win81", "win8-arm"})

    graph.AddRuntime("win10", []string{"win81"})
    graph.AddRuntime("win10-x86", []string{"win10", "win81-x86"})
    graph.AddRuntime("win10-x64", []string{"win10", "win81-x64"})
    graph.AddRuntime("win10-arm", []string{"win10", "win81-arm"})
    graph.AddRuntime("win10-arm64", []string{"win10", "win-arm64"})

    // Linux (all import any)
    graph.AddRuntime("linux", []string{"any"})
    graph.AddRuntime("linux-x64", []string{"linux"})
    graph.AddRuntime("linux-arm", []string{"linux"})
    graph.AddRuntime("linux-arm64", []string{"linux"})

    // Ubuntu
    graph.AddRuntime("ubuntu", []string{"linux"})
    graph.AddRuntime("ubuntu-x64", []string{"ubuntu", "linux-x64"})
    graph.AddRuntime("ubuntu.20.04-x64", []string{"ubuntu-x64"})
    graph.AddRuntime("ubuntu.22.04-x64", []string{"ubuntu-x64"})
    graph.AddRuntime("ubuntu.24.04-x64", []string{"ubuntu-x64"})

    // Debian
    graph.AddRuntime("debian", []string{"linux"})
    graph.AddRuntime("debian-x64", []string{"debian", "linux-x64"})
    graph.AddRuntime("debian.11-x64", []string{"debian-x64"})
    graph.AddRuntime("debian.12-x64", []string{"debian-x64"})

    // RHEL/CentOS
    graph.AddRuntime("rhel", []string{"linux"})
    graph.AddRuntime("rhel-x64", []string{"rhel", "linux-x64"})
    graph.AddRuntime("rhel.7-x64", []string{"rhel-x64"})
    graph.AddRuntime("rhel.8-x64", []string{"rhel-x64"})
    graph.AddRuntime("rhel.9-x64", []string{"rhel-x64"})

    // Alpine
    graph.AddRuntime("alpine", []string{"linux"})
    graph.AddRuntime("alpine-x64", []string{"alpine", "linux-x64"})
    graph.AddRuntime("alpine.3.17-x64", []string{"alpine-x64"})
    graph.AddRuntime("alpine.3.18-x64", []string{"alpine-x64"})

    // macOS (all import any)
    graph.AddRuntime("osx", []string{"any"})
    graph.AddRuntime("osx-x64", []string{"osx"})
    graph.AddRuntime("osx-arm64", []string{"osx"})
    graph.AddRuntime("osx.10.12-x64", []string{"osx-x64"})
    graph.AddRuntime("osx.10.13-x64", []string{"osx-x64"})
    graph.AddRuntime("osx.10.14-x64", []string{"osx-x64"})
    graph.AddRuntime("osx.10.15-x64", []string{"osx-x64"})
    graph.AddRuntime("osx.11-x64", []string{"osx-x64"})
    graph.AddRuntime("osx.12-x64", []string{"osx-x64"})
    graph.AddRuntime("osx.12-arm64", []string{"osx-arm64"})
    graph.AddRuntime("osx.13-x64", []string{"osx-x64"})
    graph.AddRuntime("osx.13-arm64", []string{"osx-arm64"})
    graph.AddRuntime("osx.14-arm64", []string{"osx-arm64"})

    return graph
}
```

---

### 5. GetAllCompatibleRIDs ⚠️ MISSING API

**Guide Implementation**: Not present

**NuGet.Client** (RuntimeGraph.cs:1658-1686):
```csharp
// GetAllCompatibleRIDs returns all RIDs compatible with the target RID
public IEnumerable<string> GetAllCompatibleRIDs(string targetRID)
{
    var compatible = new List<string>();

    if (!Runtimes.TryGetValue(targetRID, out var target))
    {
        return compatible;
    }

    var visited = new HashSet<string>();
    CollectImports(target, compatible, visited);

    return compatible;
}
```

**Impact**:
- Asset selector needs this to try RIDs in fallback order
- Without it, must recompute compatible RIDs for each asset group

**Recommendation**: Add `ExpandRuntime()` method (see section 2)

---

### 6. RuntimeDependencySet ⚠️ MUST IMPLEMENT

**NuGet.Client Feature**:
```json
{
  "runtimes": {
    "win10-x64": {
      "#import": ["win10", "win-x64"],
      "MyPackage": {
        "SomePackage": "1.0.0",
        "AnotherPackage": "2.0.0"
      }
    }
  }
}
```

This allows packages to specify additional dependencies that only apply when running on specific RIDs.

**Verdict**: ⚠️ Must be added to M3.13 for complete NuGet.Client parity.

---

### 7. CompatibilityProfile ("supports") ⚠️ MUST IMPLEMENT

**NuGet.Client Feature**:
```json
{
  "supports": {
    "net46.app": {
      "net46": ["win", "win-x86", "win-x64"]
    }
  }
}
```

This defines named compatibility profiles for portable apps.

**Verdict**: ⚠️ Must be added to M3.13 for complete NuGet.Client parity.

---

## Recommendations Summary

### Must Fix (Critical for Correctness)
1. ✅ **Implement BFS RID expansion** - Add `ExpandRuntime()` method
2. ✅ **Add 'any' and 'base' RIDs** - Update `LoadDefaultRuntimeGraph()`
3. ✅ **Fix RID inheritance** - OS RIDs should import 'any', not nil

### Should Fix (Performance & Completeness)
4. ⚠️ **Add expansion caching** - Cache `ExpandRuntime()` results
5. ⚠️ **Expand default RID graph** - Add Debian, RHEL, Alpine
6. ⚠️ **Add more Windows versions** - win7, win8, win81 chains
7. ⚠️ **RuntimeDependencySet** - Essential for RID-specific package dependencies
8. ⚠️ **CompatibilityProfile** - Essential for portable app compatibility

---

## Testing Recommendations

After implementing fixes, validate against NuGet.Client with these test cases:

### Test 1: RID Expansion Order
```go
func TestExpandRuntime_OrderMatches NuGetClient(t *testing.T) {
    graph := LoadDefaultRuntimeGraph()

    // Test: win10-x64 expansion should match NuGet.Client order
    expanded := graph.ExpandRuntime("win10-x64")
    expected := []string{
        "win10-x64",  // Self
        "win10",      // Version-specific parent
        "win-x64",    // Arch-specific parent
        "win81-x64",  // Previous version (from win10)
        "win81",      // Previous version parent
        "win8-x64",   // Continue chain...
        // ... etc
        "win",        // OS base
        "any",        // Platform-agnostic
        "base",       // Root
    }

    if !reflect.DeepEqual(expanded, expected) {
        t.Errorf("RID expansion order doesn't match NuGet.Client")
    }
}
```

### Test 2: 'any' RID Fallback
```go
func TestAnyRIDFallback(t *testing.T) {
    graph := LoadDefaultRuntimeGraph()

    // Any RID should be compatible with packages that only have 'any'
    assert.True(t, graph.AreCompatible("win10-x64", "any"))
    assert.True(t, graph.AreCompatible("linux-x64", "any"))
    assert.True(t, graph.AreCompatible("osx-arm64", "any"))
}
```

### Test 3: Load from JSON
```go
func TestLoadFromJSON_MatchesNuGetClientFormat(t *testing.T) {
    jsonData := `{
        "runtimes": {
            "base": {},
            "any": { "#import": ["base"] },
            "win": { "#import": ["any"] },
            "win-x64": { "#import": ["win"] }
        }
    }`

    graph, err := LoadFromJSON([]byte(jsonData))
    require.NoError(t, err)

    // Verify structure matches NuGet.Client
    assert.True(t, graph.AreCompatible("win-x64", "base"))
    assert.True(t, graph.AreCompatible("win-x64", "any"))
    assert.True(t, graph.AreCompatible("win-x64", "win"))
}
```

---

## Conclusion

The M3.13 guide is **80% correct** but needs critical fixes:

1. **BFS expansion algorithm** - Required for correct asset selection
2. **Add 'any' and 'base' RIDs** - Required for official RID catalog compatibility
3. **Caching** - Required for acceptable performance

After these fixes, gonuget's RID resolution will match NuGet.Client's behavior exactly.
